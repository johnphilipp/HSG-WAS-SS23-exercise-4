{"version":3,"file":"ActorExtractLinksQuadPatternQuery.js","sourceRoot":"","sources":["ActorExtractLinksQuadPatternQuery.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IActionExtractLinks, IActorExtractLinksOutput } from '@comunica/bus-extract-links';\nimport { ActorExtractLinks } from '@comunica/bus-extract-links';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type { IActorArgs, IActorTest } from '@comunica/core';\nimport type { IActionContext } from '@comunica/types';\nimport { DataFactory } from 'rdf-data-factory';\nimport type * as RDF from 'rdf-js';\nimport type { QuadTermName } from 'rdf-terms';\nimport { filterQuadTermNames, getNamedNodes, getTerms, matchPatternComplete } from 'rdf-terms';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { Util as AlgebraUtil } from 'sparqlalgebrajs';\n\nconst DF = new DataFactory<RDF.BaseQuad>();\nconst VAR = DF.variable('__comunica:pp_var');\n\n/**\n * A comunica Traverse Quad Pattern Query RDF Metadata Extract Actor.\n */\nexport class ActorExtractLinksQuadPatternQuery extends ActorExtractLinks {\n  private readonly onlyVariables: boolean;\n\n  public constructor(args: IActorExtractLinksQuadPatternQueryArgs) {\n    super(args);\n  }\n\n  public static getCurrentQuery(context: IActionContext): Algebra.Operation | undefined {\n    const currentQueryOperation: Algebra.Operation | undefined = context.get(KeysInitQuery.query);\n    if (!currentQueryOperation) {\n      return;\n    }\n    return currentQueryOperation;\n  }\n\n  public static matchQuadPatternInOperation(quad: RDF.Quad, operation: Algebra.Operation): RDF.BaseQuad[] {\n    const matchingPatterns: RDF.BaseQuad[] = [];\n    AlgebraUtil.recurseOperation(operation, {\n      pattern(pattern: Algebra.Pattern) {\n        if (matchPatternComplete(quad, pattern)) {\n          matchingPatterns.push(pattern);\n        }\n        return false;\n      },\n      path(path: Algebra.Path) {\n        AlgebraUtil.recurseOperation(path, {\n          link(link: Algebra.Link) {\n            const pattern = DF.quad(VAR, link.iri, VAR, path.graph);\n            if (matchPatternComplete(quad, pattern)) {\n              matchingPatterns.push(pattern);\n            }\n            return false;\n          },\n          nps(nps: Algebra.Nps) {\n            for (const iri of nps.iris) {\n              const pattern = DF.quad(VAR, iri, VAR, path.graph);\n              if (matchPatternComplete(quad, pattern)) {\n                matchingPatterns.push(pattern);\n              }\n            }\n            return false;\n          },\n        });\n        return false;\n      },\n    });\n    return matchingPatterns;\n  }\n\n  public async test(action: IActionExtractLinks): Promise<IActorTest> {\n    if (!ActorExtractLinksQuadPatternQuery.getCurrentQuery(action.context)) {\n      throw new Error(`Actor ${this.name} can only work in the context of a query.`);\n    }\n    return true;\n  }\n\n  public async run(action: IActionExtractLinks): Promise<IActorExtractLinksOutput> {\n    const operation: Algebra.Operation = ActorExtractLinksQuadPatternQuery\n      .getCurrentQuery(action.context)!;\n\n    return {\n      links: await ActorExtractLinks.collectStream(action.metadata, (quad, links) => {\n        const matchingPatterns = ActorExtractLinksQuadPatternQuery\n          .matchQuadPatternInOperation(quad, operation);\n        if (matchingPatterns.length > 0) {\n          if (this.onlyVariables) {\n            // --- If we only want to follow links matching with a variable component ---\n\n            // Determine quad term names that we should check\n            const quadTermNames: Partial<Record<QuadTermName, boolean>> = {};\n            for (const quadPattern of matchingPatterns) {\n              for (const quadTermName of filterQuadTermNames(quadPattern, value => value.termType === 'Variable')) {\n                quadTermNames[quadTermName] = true;\n              }\n            }\n\n            // For the discovered quad term names, check extract the named nodes in the quad\n            for (const quadTermName of <QuadTermName[]> Object.keys(quadTermNames)) {\n              if (quad[quadTermName].termType === 'NamedNode') {\n                links.push({ url: quad[quadTermName].value });\n              }\n            }\n          } else {\n            // --- If we want to follow links, irrespective of matching with a variable component ---\n            for (const link of getNamedNodes(getTerms(quad))) {\n              links.push({ url: link.value });\n            }\n          }\n        }\n      }),\n    };\n  }\n}\n\nexport interface IActorExtractLinksQuadPatternQueryArgs\n  extends IActorArgs<IActionExtractLinks, IActorTest, IActorExtractLinksOutput> {\n  /**\n   * If only links that match a variable in the query should be included.\n   * @default {true}\n   */\n  onlyVariables: boolean;\n}\n"]}