"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorExtractLinksTree = void 0;
const bus_extract_links_1 = require("@comunica/bus-extract-links");
const rdf_data_factory_1 = require("rdf-data-factory");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * A comunica Extract Links Tree Extract Links Actor.
 */
class ActorExtractLinksTree extends bus_extract_links_1.ActorExtractLinks {
    constructor(args) {
        super(args);
    }
    async test(action) {
        return true;
    }
    async run(action) {
        return new Promise((resolve, reject) => {
            const metadata = action.metadata;
            const currentNodeUrl = action.url;
            const pageRelationNodes = new Set();
            const nodeLinks = [];
            const links = [];
            // Forward errors
            metadata.on('error', reject);
            // Invoke callback on each metadata quad
            metadata.on('data', (quad) => this.getTreeQuadsRawRelations(quad, currentNodeUrl, pageRelationNodes, nodeLinks));
            // Resolve to discovered links
            metadata.on('end', () => {
                // Validate if the node forward have the current node as implicit subject
                for (const [nodeValue, link] of nodeLinks) {
                    if (pageRelationNodes.has(nodeValue)) {
                        links.push({ url: link });
                    }
                }
                resolve({ links });
            });
        });
    }
    /**
     * A helper function to find all the relations of a TREE document and the possible next nodes to visit.
     * The next nodes are not guaranteed to have as subject the URL of the current page,
     * so filtering is necessary afterward.
     * @param quad the current quad.
     * @param url url of the page
     * @param pageRelationNodes the url of the relation node of the page that have as subject the URL of the page
     * @param nodeLinks the url of the next potential page that has to be visited,
     *  regardless if the implicit subject is the node of the page
     */
    getTreeQuadsRawRelations(quad, url, pageRelationNodes, nodeLinks) {
        // If it's a relation of the current node
        if (quad.subject.value === url && quad.predicate.equals(ActorExtractLinksTree.aRelation)) {
            pageRelationNodes.add(quad.object.value);
            // If it's a node forward
        }
        else if (quad.predicate.equals(ActorExtractLinksTree.aNodeType)) {
            nodeLinks.push([quad.subject.value, quad.object.value]);
        }
    }
}
exports.ActorExtractLinksTree = ActorExtractLinksTree;
ActorExtractLinksTree.aNodeType = DF.namedNode('https://w3id.org/tree#node');
ActorExtractLinksTree.aRelation = DF.namedNode('https://w3id.org/tree#relation');
ActorExtractLinksTree.rdfTypeNode = DF.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type');
//# sourceMappingURL=ActorExtractLinksTree.js.map